#!/usr/bin/env python

import sys
import time
import argparse
import numpy as np
from progress.bar import Bar
from pyfo.ext.pycl import jit, JustInTimeCall


def saxpy_test(a, x, y):
    return a * x + y


def cos_test(x):
    return np.cos(x)


def x_pi_test(x):
    return x * np.pi


def cospi_test(x):
    return np.cos(x * np.pi)


def acospi_test(x):
    return np.arccos(x) / np.pi


def const_test(x, y, c):
    return c[0, 0] * x + y


def measure_call(n_iterations, func, *args):
    times = []

    # avoid cold start, e.g. due to kernel compilation
    func(*args)

    for i in range(n_iterations):
        start = time.time()
        func(*args)
        end = time.time()

        if isinstance(func, JustInTimeCall):
            times.append(func.time)
        else:
            times.append(end - start)

    return (np.mean(times), np.std(times))


def run_single_gpu_tests(width, heights, opts, output):
    n_tests = 5
    results = {}
    bar = Bar('Measuring', max=n_tests*len(widths)*len(heights))

    for width in widths:
        for height in heights:
            x = np.random.random((width, height)).astype(np.float32)
            y = np.random.random((width, height)).astype(np.float32)
            c = np.ones((25, 25)).astype(np.float32)

            tests = [
                (saxpy_test, (2.0, x, y)),
                (cos_test, (x,)),
                (cospi_test, (x,)),
                (acospi_test, (x,)),
                (const_test, (x, y, c))
            ]

            for func, args in tests:
                fname = func.__name__
                mean_np, std_np = measure_call(opts.iterations, func, *args)
                mean_cl, std_cl = measure_call(opts.iterations, jit(func, opts.opt_level), *args)
                tup = (mean_np, std_np, mean_cl, std_cl)

                if fname in results:
                    results[fname][(width, height)] = tup
                else:
                    results[fname] = {(width, height): tup}

                bar.next()

    bar.finish()

    output.write("width  height  ")

    for name in results:
        output.write('mnp_{name}  mcl_{name}  speed_{name}  '.format(name=name))

    output.write("\n")

    for width in widths:
        for height in heights:
            output.write('{}  {}  '.format(width, height))

            for name in results:
                mean_np, std_np, mean_cl, std_cl = results[name][(width, height)]
                output.write('{}  {}  {}  '.format(mean_np, mean_cl, mean_np / mean_cl))

            output.write('\n')


def range_from(s):
    """
    Split *s* separated by ':' into int triple, filling missing values with 1s.
    """
    lst = [int(x) for x in s.split(':')]

    if len(lst) == 1:
        frm = lst[0]
        return (frm, frm + 1, 1)

    if len(lst) == 2:
        return (lst[0], lst[1], 1)

    if len(lst) == 3:
        return (lst[0], lst[1], lst[2])

    raise ValueError("Cannot parse {}".format(s))


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('--opt-level', type=int, choices=[0, 1, 2], default=2,
                        help="Optimization level to use")

    parser.add_argument('--width', type=str, default='1024',
                        help="Width or range of width of a generated projection")

    parser.add_argument('--height', type=str, default='1024',
                        help="Height or range of height of a generated projection")

    parser.add_argument('--iterations', type=int, default=10,
                        help="Number of iterations per test")

    parser.add_argument('--output', type=str,
                        help="Output file for results")

    args = parser.parse_args()
    output = sys.stdout if not args.output else open(args.output, 'w')

    widths = list(range(*range_from(args.width)))
    heights = list(range(*range_from(args.height)))

    run_single_gpu_tests(widths, heights, args, output)
