#!/usr/bin/env python

import sys
import time
import argparse
import numpy as np
from progress.spinner import Spinner
from pyfo.ext.pycl import jit, JustInTimeCall


def saxpy_test(a, x, y):
    return a * x + y


def cos_test(x):
    return np.cos(x)


def x_pi_test(x):
    return x * np.pi


def cospi_test(x):
    return np.cos(x * np.pi)


def acospi_test(x):
    return np.arccos(x) / np.pi


def const_test(x, y, c):
    return c[0, 0] * x + y


def reco_cl(sinogram, center, sines, cosines):
    width = get_global_size(0)
    x = float(get_global_id(0))
    y = float(get_global_id(1))
    s = 0.0
    for i in range(get_global_size(1)):
        pos = (x - width / 2) * sines[i] + (y - width / 2) * cosines[i] + center
        if pos >= 0 and pos < width:
            s += sinogram[i, int(pos)]

    return s


def reco_np(sinogram, center, sines, cosines):
    width = sinogram.shape[1]
    half = width / 2
    y_indices, x_indices = np.mgrid[-half:half, -half:half]
    slice = np.zeros((width, width)).astype(np.float32)

    times = []

    for i in range(sinogram.shape[0]):
        pos = sines[i] * x_indices + cosines[i] * y_indices + center
        pos[np.where((pos < 0) | (pos >= width))] = 0
        slice += sinogram[i, pos.astype(np.int)]

    return slice


def measure_call(n_iterations, func, *args):
    times = []

    # avoid cold start, e.g. due to kernel compilation
    func(*args)

    for i in range(n_iterations):
        start = time.time()
        func(*args)
        end = time.time()

        if isinstance(func, JustInTimeCall):
            times.append(func.time)
        else:
            times.append(end - start)

    return (np.mean(times), np.std(times))


def run_tests(widths, heights, opts, output):
    results = {}
    spinner = Spinner('Measuring ')

    for width in widths:
        for height in heights:
            x = np.random.random((height, width)).astype(np.float32)
            y = np.random.random((height, width)).astype(np.float32)
            c = np.ones((25, 25)).astype(np.float32)
            sines = np.sin(np.linspace(0, np.pi, height))
            cosines = np.cos(np.linspace(0, np.pi, height))

            tests = [
                (saxpy_test, saxpy_test, (2.0, x, y)),
                (cos_test, cos_test, (x,)),
                (cospi_test, cospi_test, (x,)),
                (acospi_test, acospi_test, (x,)),
                (const_test, const_test, (x, y, c)),
            ]

            def empty(*args):
                pass

            if opts.with_reco == "numpy":
                tests.append((reco_np, reco_cl, (x, width / 2.0, sines, cosines)))
            elif opts.with_reco == "empty":
                tests.append((empty, reco_cl, (x, width / 2.0, sines, cosines)))

            for np_func, cl_func, args in tests:
                fname = np_func.__name__
                mean_np, std_np = measure_call(opts.iterations, np_func, *args)

                jitted = jit(cl_func, opts.opt_level, opts.multi_gpu)
                mean_cl, std_cl = measure_call(opts.iterations, jitted, *args)
                tup = (mean_np, std_np, mean_cl, std_cl)

                if fname in results:
                    results[fname][(width, height)] = tup
                else:
                    results[fname] = {(width, height): tup}

                spinner.next()

    output.write("width  height  ")

    for name in results:
        output.write('mnp_{name}  mcl_{name}  speed_{name}  '.format(name=name))

    output.write("\n")

    for width in widths:
        for height in heights:
            output.write('{}  {}  '.format(width, height))

            for name in results:
                mean_np, std_np, mean_cl, std_cl = results[name][(width, height)]
                output.write('{}  {}  {}  '.format(mean_np, mean_cl, mean_np / mean_cl))

            output.write('\n')


def range_from(s):
    """
    Split *s* separated by ':' into int triple, filling missing values with 1s.
    """
    lst = [int(x) for x in s.split(':')]

    if len(lst) == 1:
        frm = lst[0]
        return (frm, frm + 1, 1)

    if len(lst) == 2:
        return (lst[0], lst[1], 1)

    if len(lst) == 3:
        return (lst[0], lst[1], lst[2])

    raise ValueError("Cannot parse {}".format(s))


if __name__ == '__main__':
    parser = argparse.ArgumentParser()

    parser.add_argument('--opt-level', type=int, choices=[0, 1, 2], default=2,
                        help="Optimization level to use")

    parser.add_argument('--width', type=str, default='1024',
                        help="Width or range of width of a generated projection")

    parser.add_argument('--height', type=str, default='1024',
                        help="Height or range of height of a generated projection")

    parser.add_argument('--iterations', type=int, default=10,
                        help="Number of iterations per test")

    parser.add_argument('--output', type=str,
                        help="Output file for results")

    parser.add_argument('--multi-gpu', action='store_true', default=False,
                        help="Enable multi GPU execution")

    parser.add_argument('--with-reco', type=str, choices=["empty","numpy", ""], default="",
                        help="Enable reconstruction test")

    args = parser.parse_args()
    output = sys.stdout if not args.output else open(args.output, 'w')

    widths = list(range(*range_from(args.width)))
    heights = list(range(*range_from(args.height)))

    run_tests(widths, heights, args, output)
